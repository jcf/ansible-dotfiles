#!/usr/bin/env ruby -rubygems -wKU

help = <<-MSG
Usage: gorgeous [-i] [-F <in-format>] [-T <out-format>] [-q <query>] [-o <destination>] FILE ...

This utility converts data between different formats.
Formats are one of:  json, xml, yaml, ruby, email

Input can be read from STDIN as well as files given on the command-line.

Options:
  -i    Convert file in-place
  -F    Input format
  -T    Output format
  -q    Query string selecting a single field to output
  -o    Write output to file instead of STDOUT
MSG

if ARGV.index('-h') or ARGV.index('--help')
  puts help
  exit
end

help_usage = help.split("\n", 2).first

options = help_usage.scan(/[^\w-](-[a-z])(?: <(.+?)>)?/i).inject({}) do |opts, (flag, value)|
  if value.nil?
    opts[flag] = true if ARGV.delete flag
  elsif idx = ARGV.index(flag)
    opts[flag] = ARGV[idx + 1]
    2.times { ARGV.delete_at idx }
  end
  opts
end

in_place = options['-i']
filter_field = options['-q']
output_format = filter_field && :field
input_format = options['-F'] && options['-F'].to_sym
output_format ||= options['-T'] && options['-T'].to_sym
destination = options['-o']
from_stdin = !$stdin.tty?

if from_stdin
  if in_place
    warn "can't edit stdin in place"
    exit 1
  end
elsif in_place and destination
  warn "can't combine -i and -o flags"
  exit 1
elsif filter_field and options['-T']
  warn "can't combine -T and -q flags"
  exit 1
elsif ARGV.empty?
  warn help_usage
  exit 1
end

# clobber the input file
destination = ARGV.first if in_place

class Gorgeous
  def self.filename_to_format(filename)
    case File.extname(filename)
    when '.json' then :json
    when '.xml', '.html' then :xml
    when '.rb' then :ruby
    when '.yml', '.yaml' then :yaml
    end
  end
  
  def self.pretty_xml(ugly)
    tidy = Nokogiri::XSLT DATA.read
    tidy.transform(ugly).to_s
  end
  
  def self.convert_utf8(string, from_charset)
    if from_charset.nil? or from_charset.downcase == 'utf-8'
      string
    else
      require 'iconv'
      Iconv.conv 'utf-8', from_charset, string
    end
  end
  
  def self.headers_from_mail(email)
    require 'active_support/ordered_hash'
    require 'active_support/core_ext/object/blank'

    address_field = lambda { |name|
      if field = email.header[name.to_s]
        values = field.addrs.map { |a|
          encoding = a.raw.input =~ /=\?([\w-]+)/ && $1
          Gorgeous.convert_utf8(a.decoded, encoding)
        }
        values.size < 2 ? values.first : values
      end
    }
    header_value = lambda { |name|
      field = email.header[name.to_s] and field.value.to_s
    }
    
    data = ActiveSupport::OrderedHash.new
    data[:subject] = email.subject
    data[:from] = address_field['from']
    data[:to] = address_field['to']
    data[:cc] = address_field['cc']
    data[:bcc] = address_field['bcc']
    data[:reply_to] = address_field['reply-to']
    data[:return_path] = email.return_path

    data[:message_id] = email.message_id
    data[:in_reply_to] = email.in_reply_to
    data[:references] = email.references

    data[:date] = email.date
    data[:sender] = email.sender
    data[:delivered_to] = header_value['delivered-to']
    data[:original_sender] = header_value['x-original-sender']
    data[:content_type] = email.content_type.to_s.split(';', 2).first.presence
    data[:precedence] = header_value['precedence']
    
    data.tap { |hash| hash.reject! { |k,v| v.nil? } }
  end
  
  def initialize(input, filename = nil, format = nil)
    @input = input
    @filename = filename
    @format = format
  end
  
  def to_s
    @str ||= @input.respond_to?(:read) ? @input.read : @input
  end
  
  def format
    @format ||= begin
      if @filename
        self.class.filename_to_format(@filename)
      else
        guess_format
      end
    end
  end
  
  def to_hash
    case format
    when :xml
      require 'active_support/core_ext/hash/conversions'
      Hash.from_xml(to_s)
    when :json
      require 'yajl/json_gem'
      JSON.parse to_s
    when :yaml
      require 'yaml'
      YAML.load to_s
    when :email
      self.class.headers_from_mail to_mail
    when :ruby
      eval to_s
    else
      raise ArgumentError, "don't know how to decode #{format}"
    end
  end
  
  def to_xml
    require 'nokogiri'
    Nokogiri to_s
  end
  
  def to_mail
    require 'mail'
    raw = to_s.lstrip
    raw << "\n" unless raw[-1, 1] == "\n"
    Mail.new raw
  end
  
  private
  
  def guess_format
    case to_s
    when /\A\s*[\[\{]/ then :json
    when /\A\s*</ then :xml
    when /\A---\s/ then :yaml
    end
  end
end

input = Gorgeous.new(ARGF, ARGV.first, input_format)

unless input.format
  warn "unrecognized input format; specify explicit format with `-F <format>`"
  exit 1
end

output_format ||= if destination
  Gorgeous.filename_to_format(destination)
else
  input.format
end

if output_format == :ruby
  require 'pp'
  output = input.to_hash.pretty_inspect
elsif output_format == :json
  require 'yajl/json_gem'
  output = JSON.pretty_generate input.to_hash
elsif output_format == :yaml
  require 'yaml'
  output = YAML.dump input.to_hash
elsif input_format == :email and output_format == :xml
  require 'nokogiri'
  email = input.to_mail
  part = email.html_part
  html = Gorgeous.convert_utf8(part.decode_body, part.charset)
  ugly = Nokogiri::HTML html
  output = Gorgeous.pretty_xml(ugly)
elsif input_format == :email and output_format == :txt
  email = input.to_mail
  part = email.text_part
  output = Gorgeous.convert_utf8(part.decode_body.strip, part.charset)
elsif output_format == :xml
  output = Gorgeous.pretty_xml(input.to_xml)
elsif output_format == :field
  output = input.to_hash[filter_field]
else
  warn "don't know how to convert #{input_format} to #{output_format}"
  exit 1
end

if destination
  begin
    File.open(destination, 'w') { |f| f << output }
  rescue Errno::ENOENT
    warn "error opening #{destination} for writing"
    exit 1
  end
else
  puts output
end

__END__
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <xsl:output method="xml" encoding="UTF-8"/>
  <xsl:param name="indent-increment" select="'   '"/>
  
  <xsl:template name="newline">
    <xsl:text disable-output-escaping="yes">
</xsl:text>
  </xsl:template>
  
  <xsl:template match="comment() | processing-instruction()">
    <xsl:param name="indent" select="''"/>
    <xsl:call-template name="newline"/>    
    <xsl:value-of select="$indent"/>
    <xsl:copy />
  </xsl:template>
  
  <xsl:template match="text()">
    <xsl:param name="indent" select="''"/>
    <xsl:call-template name="newline"/>    
    <xsl:value-of select="$indent"/>
    <xsl:value-of select="normalize-space(.)"/>
  </xsl:template>
    
  <xsl:template match="text()[normalize-space(.)='']"/>
  
  <xsl:template match="*">
    <xsl:param name="indent" select="''"/>
    <xsl:call-template name="newline"/>    
    <xsl:value-of select="$indent"/>
      <xsl:choose>
       <xsl:when test="count(child::*) > 0">
        <xsl:copy>
         <xsl:copy-of select="@*"/>
         <xsl:apply-templates select="*|text()">
           <xsl:with-param name="indent" select="concat ($indent, $indent-increment)"/>
         </xsl:apply-templates>
         <xsl:call-template name="newline"/>
         <xsl:value-of select="$indent"/>
        </xsl:copy>
       </xsl:when>       
       <xsl:otherwise>
        <xsl:copy-of select="."/>
       </xsl:otherwise>
     </xsl:choose>
  </xsl:template>    
</xsl:stylesheet>